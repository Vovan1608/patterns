"use strict";

/*
Воспользуемся шаблоном применения функции обратного вызова –
оформим операцию скрытия узла дерева в виде отдельной
функции обратного вызова и делегируем ей полномочия выполнения
операции:
*/

// измененный вариант функции findNodes(),
// принимающий функцию обратного вызова
var findNodes = function (callback) {
	var i = 100000,
	nodes = [],
	found;
	// проверить, является ли объект callback функцией
	if (typeof callback !== “function”) {
	callback = false;
	}
	while (i) {
		i -= 1;
// здесь находится сложная логика выбора узлов...
// теперь вызвать функцию callback:
		if (callback) {
			callback(found);
		}
	nodes.push(found);
	}
	return nodes;
};

//Реализация функции hide() теперь выглядит еще проще благодаря тому,
//что в ней не нужно выполнять цикл по элементам массива:

// функция обратного вызова
var hide = function (node) {
	node.style.display = 'none';
};
// отыскать узлы и скрыть их
findNodes(hide);


//!Примером таких частных данных может служить
// счетчик, наращиваемый при каждом обращении к нему:
var setup = function () {
	var count = 0;
	return function () {
		return (count += 1);
	};
};
// пример использования
var next = setup();
next(); // вернет 1
next(); // 2
next(); // 3

//!Функции могут определяться динамически и присваиваться переменным.
/*Если создать новую функцию и присвоить ее переменной, кото-
рая уже хранит другую функцию, старая функция будет затерта новой.

Это напоминает переустановку указателя на новую функцию. Все это
можно реализовать в теле старой функции. В этом случае функция
переопределит саму себя новой реализацией. На первый взгляд такой
прием выглядит сложнее, чем это есть на самом деле, поэтому давайте
рассмотрим простой пример:
*/
var scareMe = function () {
	alert('Boo!');
	scareMe = function () {
		alert('Double boo!');
	};
};
// вызов самоопределяемой функции
scareMe(); // Boo!
scareMe(); // Double boo!
/*Этот прием удобно использовать, когда требуется выполнить некоторые
операции по инициализации, причем эти операции должны быть вы-
полнены всего один раз.

Недостаток этого шаблона состоит в том, что все свойства, добавленные
к прежней функции, будут потеряны в момент переопределения. Кроме
того, если прежняя функция использовалась под другим именем, на-
пример, была присвоена другой переменной или была задействована
как метод объекта, то в таких случаях переопределение функции ни-
когда не произойдет и будет выполняться тело прежней функции.
*/