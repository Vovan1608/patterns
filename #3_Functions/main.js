"use strict";

var adam = new Person('Adam');
adam.say(); // “I am Adam”

/*Этот новый шаблон очень напоминает создание объектов в языке Java с
использованием класса Person. Синтаксис очень похож, но в действи
тельности в языке JavaScript отсутствуют классы, и Person – это всего  лишь функция.
Ниже приводится одна из возможных реализаций функции-конструк тора Person.
*/

var Person = function (name) {
	this.name = name;
	this.say = function () {
		return “I am “ + this.name;
	};
};

/*При вызове функции-конструктора с оператором new внутри функции  происходит следующее:
• Создается пустой объект, наследующий свойства и методы прототи па функции, и ссылка
	на него сохраняется в переменой this.
• Добавление новых свойств и методов в объект осуществляется с по мощью ссылки this.
• В конце функция неявно возвращает объект, на который ссылается  переменная this
	(если явно не возвращается никакой другой объект).
Вот как примерно выглядит то, что происходит за кулисами: var Person = function (name) {
 * создается пустой объект с использованием литерала var this = {};
 * добавляются свойства и методы
	this.name = name;
	this.say = function () {
	return “I am “ + this.name;
	};
 * return this;
*/


/*В конструкторе можно  проверить, является ли ссылка this экземпляром конструктора, 
и если  не является, вызвать конструктор еще раз, но уже с оператором new:
*/
function Waffle() {
	if (!(this instanceof Waffle)) {
		return new Waffle();
	}
	this.tastes = 'yummy';
}
Waffle.prototype.wantAnother = true;
// проверка вызовов
var first = new Waffle(),
		second = Waffle();
console.log(first.tastes); // “yummy”
console.log(second.tastes); // “yummy”
console.log(first.wantAnother); // true
console.log(second.wantAnother); // true

//Другой распространенный способ проверки экземпляра состоит в том,  чтобы сравнить
//не с конкретным именем конструктора, а со свойством  arguments.callee.
if (!(this instanceof arguments.callee)) {
	return new arguments.callee();
}

/*В этом шаблоне используется то обстоятельство, что внутри каждой  функции создается
объект с именем arguments, содержащий все параметры, переданные функции при вызове.
А объект arguments имеет свой ство callee, которое ссылается на вызываемую функцию.
Тем не менее  имейте в виду, что свойство arguments.callee недоступно в строгом режиме
ES5, поэтому лучше воздержаться от его использования в будущем, а также удалять
все обращения к этому свойству, которые встретятся  вам в существующих сценариях.
*/