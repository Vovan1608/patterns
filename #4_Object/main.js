"use strict";

//! ========== Пространство имен

/*создав единственный глобальный объект, назовем его MYAPP, и превратив все
функции и переменные в свойства этого глобального объекта:
*/

// ПОСЛЕ: 1 глобальная переменная
// глобальный объект
var MYAPP = {};
// конструкторы
MYAPP.Parent = function () {};
MYAPP.Child = function () {};
// переменная
MYAPP.some_var = 1;
// объект-контейнер
MYAPP.modules = {};
// вложенные объекты
MYAPP.modules.module1 = {};
MYAPP.modules.module1.data = {a: 1, b: 2};
MYAPP.modules.module2 = {};

/*
В качестве имени глобального объекта пространства имен вы можете
выбрать, например, имя вашего приложения или библиотеки, доменное
имя или название своей компании. Часто разработчики следуют согла-
шению об именовании, согласно которому имена глобальных перемен-
ных конструируются только из ЗАГЛАВНЫХ СИМВОЛОВ.
*/

//! ======== Универсальная функция для создания пространства имен

// применение функции пространства имен
MYAPP.namespace(‘MYAPP.modules.module2’);
// этот вызов эквивалентен следующей конструкции:
// var MYAPP = {
// modules: {
// module2: {}
// }
// };

// Далее приводится пример реализации этой функции, в котором ис-
// пользован принцип неразрушения, то есть если пространство имен с за-
// данным именем уже существует, оно не будет создано заново:

var MYAPP = MYAPP || {};
MYAPP.namespace = function (ns_string) {
	var parts = ns_string.split(‘.’),
			parent = MYAPP,
			i;
	// отбросить начальный префикс – имя глобального объекта
	if (parts[0] === “MYAPP”) {
		parts = parts.slice(1);
	}
	for (i = 0; i < parts.length; i += 1) {
	// создать свойство, если оно отсутствует
		if (typeof parent[parts[i]] === “undefined”) {
			parent[parts[i]] = {};
		}
		parent = parent[parts[i]];
	}
	return parent;
};

// Такая реализация делает допустимыми все следующие варианты ис-
// пользования функции:

// присваивать возвращаемое значение локальной переменной
var module2 = MYAPP.namespace(‘MYAPP.modules.module2’);
module2 === MYAPP.modules.module2; // true
// опускать начальный префикс `MYAPP`
MYAPP.namespace(‘modules.module51’);

// создавать глубоко вложенные пространства имен
MYAPP.namespace(‘once.upon.a.time.there.was.this.long.nested.property’);

//! ========== Частные члены

// рассмотрим пример создания частного члена, недоступного за пределами объекта:
function Gadget() {
	// частный член
	var name = 'iPod';
	// общедоступная функция
	this.getName = function () {
		return name;
	};
}
var toy = new Gadget();

// имя `name` не определено, частный член
console.log(toy.name); // undefined

// общедоступный метод может обратиться к частному члену `name`
console.log(toy.getName()); // “iPod”

// Как видите, в JavaScript можно легко создавать частные члены. Все, что
// для этого необходимо, – обернуть данные, которые вы хотели бы оста-
// вить частными, в функцию, сделав их локальными по отношению к этой
// функции и, следовательно, недоступными за пределами функции.

//! ========== Объявление частных функций общедоступными методами

// Рассмотрим пример, основанный на одном из шаблонов сокрытия дан-
// ных – определении частных членов в литералах объектов:

var myarray;
(function () {
	var astr = '[object Array]',
			toString = Object.prototype.toString;
	function isArray(a) {
		return toString.call(a) === astr;
	}
	function indexOf(haystack, needle) {
		var i = 0,
				max = haystack.length;
		for (; i < max; i += 1) {
			if (haystack[i] === needle) {
				return i;
			}
		}
	return -1;
	}
	myarray = {
	isArray: isArray,
	indexOf: indexOf,
	inArray: indexOf
	};
}());
/* Здесь есть две частные переменные и две частные функции, isArray()
и indexOf(). В конце немедленно вызываемой функции объект myarray за-
полняется функциональными возможностями, доступ к которым требу-
ется открыть. В данном случае одно и то же частное свойство indexOf()
открывается под двумя разными именами: indexOf в стиле ECMAScript 5
и inArray в духе языка PHP. Проверим наш объект myarray:
*/

myarray.isArray([1,2]); // true
myarray.isArray({0: 1}); // false
myarray.indexOf([“a”, “b”, “z”], “z”); // 2
myarray.inArray([“a”, “b”, “z”], “z”); // 2

// Если теперь произойдет, например, что-то неожиданное с общедоступ-
// ным методом indexOf(), частный метод indexOf() останется нетронутым,
// благодаря чему метод inArray() сохранит свою работоспособность:
myarray.indexOf = null;
myarray.inArray([“a”, “b”, “z”], “z”); // 2

//!========== Шаблон «модуль»

/* Первый шаг заключается в создании пространства имен. Воспользуем-
ся функцией namespace(), реализованной выше в этой главе, и создадим
вспомогательный модуль, содержащий методы для работы с массивами:
*/
MYAPP.namespace(‘MYAPP.utilities.array’);

/* Следующий шаг – определение модуля. На этом этапе используется не-
медленно вызываемая функция, образующая частную область видимо-
сти, если это необходимо. Немедленно вызываемая функция возвраща-
ет объект – собственно модуль с общедоступным интерфейсом, который
может использоваться программами, в которые добавляется модуль:
*/

MYAPP.utilities.array = (function () {
	return {
	// будет реализовано позже...
	};
}());

// Затем необходимо добавить общедоступные методы:
MYAPP.utilities.array = (function () {
	return {
		inArray: function (needle, haystack) {
		// ...
		},
		isArray: function (a) {
		// ...
		}
	};
}());
/* В частной области видимости, образуемой немедленно вызываемой
функцией, можно объявить частные свойства и методы, если это необ-
ходимо. В самом начале немедленно вызываемой функции следует так-
же поместить все объявления зависимостей, необходимых для модуля.
Вслед за объявлениями переменных можно поместить программный
код инициализации модуля, который будет вызываться всего один раз.
Окончательный результат – объект, возвращаемый немедленно вызы-
ваемой функцией, содержащий общедоступные члены модуля: 
*/

MYAPP.namespace(‘MYAPP.utilities.array’);
MYAPP.utilities.array = (function () {
	// зависимости
	var uobj = MYAPP.utilities.object,
			ulang = MYAPP.utilities.lang,
			// частные свойства
			array_string = '[object Array]',
			ops = Object.prototype.toString;
		// частные методы
		// ...
		// конец инструкции var
		// реализация необязательной процедуры инициализации
		// ...
		// общедоступные члены
	return {
		inArray: function (needle, haystack) {
			for (var i = 0, max = haystack.length; i < max; i += 1) {
				if (haystack[i] === needle) {
					return true;
				}
			}
		},
		isArray: function (a) {
			return ops.call(a) === array_string;
		}
		// ... другие методы и свойства
	};
}());

/* Шаблон «модуль» широко используется на практике и является реко-
мендуемым способом организации программного кода, особенно по мере
увеличения его объема.
*/